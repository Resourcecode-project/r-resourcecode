% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/plot_mesh.R
\name{plot_mesh}
\alias{plot_mesh}
\title{Plot a Triangular Mesh with Smooth Coloring (Boundary Handling)}
\usage{
plot_mesh(
  points_df,
  tri_mat,
  n = 500,
  nx = NULL,
  ny = NULL,
  draw_edges = FALSE,
  palette = "viridis",
  add_colorbar = TRUE,
  z_trans = NULL,
  na_color = "transparent",
  mapsta = NULL,
  ...
)
}
\arguments{
\item{points_df}{A data.frame with columns \code{lon}, \code{lat}, \code{z},
and optionally \code{mapsta}.}

\item{tri_mat}{A 3 x n matrix of integers defining triangles (indices into points_df).}

\item{n}{Integer. Raster resolution (n x n). Ignored if \code{nx} and \code{ny} are provided.}

\item{nx}{Number of pixels in x-direction. Overrides \code{n} if provided.}

\item{ny}{Number of pixels in y-direction. Overrides \code{n} if provided.}

\item{draw_edges}{Logical. If TRUE, triangle edges are drawn.}

\item{palette}{Viridis palette: "viridis", "magma", "plasma", "cividis", etc.}

\item{add_colorbar}{Logical. If TRUE, adds a colorbar to the plot.}

\item{z_trans}{Function. Optional transformation of the z values for coloring
(e.g., \code{sqrt}, \code{log}).}

\item{na_color}{Color for pixels outside any triangle. Can be "transparent" or any valid R color.}

\item{mapsta}{Optional numeric vector in \code{points_df} identifying boundary vertices
(1 = boundary, 0 = interior).}

\item{...}{Additional arguments passed to \code{image()}
(e.g., \code{main}, \code{asp}, \code{xlab}, \code{ylab}, \code{zlim}).}
}
\value{
Invisibly returns a list with rasterized grid and triangle vertices.
}
\description{
Rasterizes a triangular mesh with smooth color interpolation, rotated 90Â° clockwise
for geospatial plotting (longitude on x-axis, latitude on y-axis, north-up).
Supports optional triangle edges, colorbar, z-scale transformations, NA handling,
and optional map boundary points via \code{mapsta}.
}
\examples{
# Create a simple grid of points
points_df <- expand.grid(lon = seq(0, 1, length.out = 5),
                        lat = seq(0, 1, length.out = 5))
points_df$z <- sqrt(points_df$lon^2+points_df$lat^2) *sin(2*pi * points_df$lon) * cos(2*pi * points_df$lat)

# Define a simple triangular mesh manually (each square split into 2 triangles)
tri_mat <- matrix(nrow = 3, ncol = 32)  # 4x4 squares * 2 triangles per square
count <- 1
for(i in 1:4){
 for(j in 1:4){
   p1 <- (i-1)*5 + j
   p2 <- p1 + 1
   p3 <- p1 + 5
   p4 <- p3 + 1
   # Triangle 1
   tri_mat[, count] <- c(p1, p2, p4); count <- count + 1
   # Triangle 2
   tri_mat[, count] <- c(p1, p4, p3); count <- count + 1
 }
}

# Define boundary points: all points on the edge of the grid
points_df$mapsta <- 0
points_df$mapsta[points_df$lon == 0 | points_df$lon == 1 |
                  points_df$lat == 0 | points_df$lat == 1] <- 1

# Plot using plot_mesh
plot_mesh(points_df, tri_mat, n = 200,
         palette = "viridis",
         draw_edges = TRUE,
         add_colorbar = TRUE,
         na_color = "transparent",
         mapsta = points_df$mapsta,
         xlab = "Longitude", ylab = "Latitude", main = "Simple Map Example")
\dontrun{
 # Example on Resourcecode data
 plot_mesh(points_df = data.frame(lon = resourcecodedata::rscd_field$longitude,
           lat = resourcecodedata::rscd_field$latitude,
            z = resourcecodedata::rscd_field$depth),
            tri_mat = resourcecodedata::rscd_triangles,
            z_trans = log ,draw_edges = T, n=5000,
            asp = 1.5,
            zlim = c(-0.70,9),
            main = "Bathymetry map (sqrt scale)"
            )
}
}
